> [!TIP]
>
> **Go这样的静态编程语言来说，类型是十分重要的。因为它不仅是静态语言编译器的要求，更是我们对现实事物进行抽象的基础。对这一方面的学习，可以逐渐建立起代码设计的意识。**
>
> **Go语言的类型大体可分为`基本数据类型`、`复合数据类型`和`接口类型`这三种。其中，我们日常Go编码中使用最多的就是基本数据类型。**
>
> 

## 整型

### 有符号和无符号整型

整型分为两大类：

- 有符号整型：`int8`、`int16`、`int32`、`int64`
- 无符号整型：`uint8`、`uint16`、`uint32`、`uint64`



|  类型  | 描述                                                         |
| :----: | :----------------------------------------------------------- |
| uint8  | 无符号 8位整型 (0 到 255)                                    |
| uint16 | 无符号 16位整型 (0 到 65535)                                 |
| uint32 | 无符号 32位整型 (0 到 4294967295)                            |
| uint64 | 无符号 64位整型 (0 到 18446744073709551615)                  |
|  int8  | 有符号 8位整型 (-128 到 127)                                 |
| int16  | 有符号 16位整型 (-32768 到 32767)                            |
| int32  | 有符号 32位整型 (-2147483648 到 2147483647)                  |
| int64  | 有符号 64位整型 (-9223372036854775808 到 9223372036854775807) |

### 特殊整型

|  类型   | 描述                                                   |
| :-----: | :----------------------------------------------------- |
|  uint   | 32位操作系统上就是`uint32`，64位操作系统上就是`uint64` |
|   int   | 32位操作系统上就是`int32`，64位操作系统上就是`int64`   |
| uintptr | 无符号整型，用于存放一个指针                           |

> [!CAUTION] 
>
> - **在使用`int`和 `uint`类型时，不能假定它是32位或64位的整型，而是考虑`int`和`uint`可能在不同平台上的差异。**
> - **获取对象的长度的内建`len()`函数返回的长度可以根据不同平台的字节长度进行变化。实际使用中，切片或 map 的元素数量等都可以用`int`来表示。在涉及到二进制传输、读写文件的结构描述时，为了保持文件的结构不会受到不同编译目标平台字节长度的影响，不要使用`int`和 `uint`。**

### 字面值与格式化输出

Go语言在设计开始，就继承了C语言关于**数值字面值（Number Literal）**的语法形式。早期Go版本支持十进制、八进制、十六进制的数值字面值形式，比如：

```go
a := 53        // 十进制
b := 0700      // 八进制，以"0"为前缀
c1 := 0xaabbcc // 十六进制，以"0x"为前缀
c2 := 0Xddeeff // 十六进制，以"0X"为前缀
```

Go 1.13版本中，Go又增加了对二进制字面值的支持和两种八进制字面值的形式，比如：

```go
d1 := 0b10000001 // 二进制，以"0b"为前缀
d2 := 0B10000001 // 二进制，以"0B"为前缀
e1 := 0o700      // 八进制，以"0o"为前缀
e2 := 0O700      // 八进制，以"0O"为前缀
```

为提升字面值的可读性，Go 1.13版本还支持在字面值中增加数字分隔符“_”，分隔符可以用来将数字分组以提高可读性。比如每3个数字一组，也可以用来分隔前缀与字面值中的第一个数字：

```go
a := 5_3_7   // 十进制: 537
b := 0b_1000_0111  // 二进制位表示为10000111 
c1 := 0_700  // 八进制: 0700
c2 := 0o_700 // 八进制: 0700
d1 := 0x_5c_6d // 十六进制：0x5c6d
```

不过，这里要注意一下，Go 1.13中增加的二进制字面值以及数字分隔符，只在go.mod中的go version指示字段为Go 1.13以及以后版本的时候，才会生效，否则编译器会报错。

反过来，我们也可以通过标准库fmt包的格式化输出函数，将一个整型变量输出为不同进制的形式。比如下面就是将十进制整型值59，格式化输出为二进制、八进制和十六进制的代码：

```go
var a int8 = 59
fmt.Printf("%b\n", a) //输出二进制：111011
fmt.Printf("%d\n", a) //输出十进制：59
fmt.Printf("%o\n", a) //输出八进制：73
fmt.Printf("%O\n", a) //输出八进制(带0o前缀)：0o73
fmt.Printf("%x\n", a) //输出十六进制(小写)：3b
fmt.Printf("%X\n", a) //输出十六进制(大写)：3B
```

## 浮点型

## 复数

数学课本上将形如z=a+bi（a、b均为实数，a称为实部，b称为虚部）的数称为**复数**，这里我们也可以这么理解。相比C语言直到采用C99标准，才在complex.h中引入了对复数类型的支持，Go语言则原生支持复数类型。不过，和整型、浮点型相比，复数类型在Go中的应用就更为局限和小众，主要用于专业领域的计算，比如矢量计算等。

Go提供两种复数类型，它们分别是complex64和complex128：

- complex64的实部与虚部都是float32类型

- complex128的实部与虚部都是float64类型。

如果一个复数没有显示赋予类型，那么它的默认类型为complex128。



关于复数字面值的表示，有三种方法：

**第一种，我们可以通过复数字面值直接初始化一个复数类型变量：**

```plain
var c = 5 + 6i
var d = 0o123 + .12345E+5i // 83+12345i
```

**第二种，Go还提供了complex函数，方便我们创建一个complex128类型值：**

```plain
var c = complex(5, 6) // 5 + 6i
var d = complex(0o123, .12345E+5) // 83+12345i
```

**第三种，你还可以通过Go提供的预定义的函数real和imag，来获取一个复数的实部与虚部，返回值为一个浮点类型：**

```plain
var c = complex(5, 6) // 5 + 6i
r := real(c) // 5.000000
i := imag(c) // 6.000000
```

至于复数形式的格式化输出的问题，由于complex类型的实部与虚部都是浮点类型，所以我们可以直接运用浮点型的格式化输出方法，来输出复数类型。

## 布尔值

Go语言中以`bool`类型进行声明布尔型数据，布尔型数据只有`true（真）`和`false（假）`两个值。

> [!CAUTION]
>
> 1. **布尔类型变量的默认值为`false`**
> 2. **Go 语言中不允许将整型强制转换为布尔型**
> 3. **布尔型无法参与数值运算，也无法与其他类型进行转换**



## 字符串

Go语言中的字符串以原生数据类型出现，使用字符串就像使用其他原生数据类型（int、bool、float32、float64 等）一样。 Go 语言里的字符串的内部实现使用`UTF-8`编码。 字符串的值为`双引号(")`中的内容，可以在Go语言的源码中直接添加非ASCII码字符，例如：

```go
s1 := "xie"
s2 := "谢"
```

### 字符串转义符

Go 语言的字符串常见转义符包含回车、换行、单双引号、制表符等，如下表所示。

| 转义符 |                含义                |
| :----: | :--------------------------------: |
|  `\r`  |         回车符（返回行首）         |
|  `\n`  | 换行符（直接跳到下一行的同列位置） |
|  `\t`  |               制表符               |
|  `\'`  |               单引号               |
|  `\"`  |               双引号               |
|  `\\`  |               反斜杠               |

举例，打印一个Windows平台下的一个文件路径：

```go
package main
import (
    "fmt"
)
func main() {
    fmt.Println("str := \"c:\\goLearning\\go.exe\"")
}
```

### 多行字符串

Go语言中要定义一个多行字符串时，就必须使用`反引号`字符：

```go
s1 := `第一行
第二行
第三行
`
fmt.Println(s1)
```

反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出。

### 字符串的常用操作

| 方法                                |      介绍      |
| :---------------------------------- | :------------: |
| len(str)                            |     求长度     |
| +或fmt.Sprintf                      |   拼接字符串   |
| strings.Split                       |      分割      |
| strings.contains                    |  判断是否包含  |
| strings.HasPrefix,strings.HasSuffix | 前缀/后缀判断  |
| strings.Index(),strings.LastIndex() | 子串出现的位置 |
| strings.Join(a[]string, sep string) |    join操作    |

## byte和rune类型

组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号（’）包裹起来，如：

```go
var a = 'x'
var b = '谢'
```

Go 语言的字符有以下两种：

1. `uint8`类型，或者叫` byte `型，代表一个`ASCII码`字符。
2. `int32`类型，或者叫`rune`类型，代表一个 `UTF-8`字符。

当需要处理中文、日文或者其他复合字符时，则需要用到`rune`类型。

Go 使用了特殊的 rune 类型来处理 Unicode，让基于 Unicode 的文本处理更为方便，也可以使用 byte 型进行默认字符串处理，性能和扩展性都有照顾。

```go
package main

import "fmt"

// 遍历字符串
func main() {
	s := "hello谢的文档库"
	for i := 0; i < len(s); i++ { //byte
		fmt.Printf("%v(%c) ", s[i], s[i])
	}
	fmt.Println()
	for _, r := range s { //rune
		fmt.Printf("%v(%c) ", r, r)
	}
}

```

输出：

```bash
104(h) 101(e) 108(l) 108(l) 111(o) 232(è) 176(°) 162(¢) 231(ç) 154( ) 132( ) 230(æ) 150( ) 135( ) 230(æ) 161(¡) 163(£) 229(å) 186(º) 147( ) 
104(h) 101(e) 108(l) 108(l) 111(o) 35874(谢) 30340(的) 25991(文) 26723(档) 24211(库) 
```

因为UTF8编码下一个中文汉字由3~4个字节组成，所以我们不能简单的按照字节去遍历一个包含中文的字符串，否则就会出现上面输出中第一行的结果。

字符串底层是一个byte数组，所以可以和`[]byte`类型相互转换。字符串是不能修改的 字符串是由byte字节组成，所以字符串的长度是byte字节的长度。 rune类型用来表示utf8字符，一个rune字符由一个或多个byte组成。



## 类型转换

Go语言中只有强制类型转换，没有隐式类型转换。该语法只能在两个类型之间支持相互转换的时候使用。

强制类型转换的基本语法如下：

```go
T(表达式)
```

其中，T表示要转换的类型。表达式包括变量、复杂算子和函数返回值等.
